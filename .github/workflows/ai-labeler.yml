name: Classify PR

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

concurrency:
  group: classify-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  models: read
  pull-requests: write

jobs:
  classify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build prompt
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR=${{ github.event.pull_request.number }}
          gh pr diff "$PR" > /tmp/pr.diff
          gh pr view "$PR" --json title --jq .title > /tmp/pr-title.txt
          gh pr view "$PR" --json body --jq '.body // ""' > /tmp/pr-body.txt

          # Compose user message
          {
            printf 'PR #%s: %s\n' "$PR" "$(cat /tmp/pr-title.txt)"
            echo ""
            cat /tmp/pr-body.txt
            echo ""
            echo "Diff (truncated):"
            head -c 100000 /tmp/pr.diff
          } > /tmp/user-message.txt

          # Build full prompt YAML: splice user message into the messages array
          # (avoids yaml round-trip which reorders keys and changes scalar styles)
          python3 -c "
with open('.github/prompts/classify-pr.prompt.yml') as f:
    lines = f.readlines()
with open('/tmp/user-message.txt') as f:
    user_msg = f.read()

# Find where messages array ends: first non-blank top-level key after 'messages:'
insert_at = len(lines)
for i, line in enumerate(lines):
    if i == 0:
        continue
    if line.strip() and not line[0].isspace():
        insert_at = i
        break

entry = ['  - role: user\n', '    content: |\n']
for ln in user_msg.splitlines():
    entry.append('      ' + ln + '\n')

lines[insert_at:insert_at] = entry
with open('/tmp/prompt.yml', 'w') as f:
    f.writelines(lines)

# Validate: last message must be the user message we just added
import yaml
doc = yaml.safe_load(open('/tmp/prompt.yml'))
assert doc['messages'][-1]['role'] == 'user', 'prompt splice failed: last message is not user'
          "

      - name: Classify
        id: classify
        uses: actions/ai-inference@v1
        with:
          prompt-file: /tmp/prompt.yml

      - name: Apply label
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LABEL=$(echo "${{ steps.classify.outputs.response }}" | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
          case "$LABEL" in
            bug|enhancement|documentation) ;;
            *) echo "Unexpected: $LABEL — skipping"; exit 0 ;;
          esac
          for L in bug enhancement documentation; do
            gh pr edit ${{ github.event.pull_request.number }} --remove-label "$L" 2>/dev/null || true
          done
          gh pr edit ${{ github.event.pull_request.number }} --add-label "$LABEL"

  breaking:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build prompt
        id: api-diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR=${{ github.event.pull_request.number }}

          # Public API surface files per SDK
          PATTERNS=(
            "go/pkg/basecamp/*.go"
            "typescript/src/client.ts" "typescript/src/errors.ts" "typescript/src/index.ts" "typescript/src/pagination.ts"
            "typescript/src/generated/services/**/*.ts" "typescript/src/generated/authorization.ts" "typescript/src/generated/schema.d.ts"
            "ruby/lib/basecamp.rb" "ruby/lib/basecamp/client.rb" "ruby/lib/basecamp/config.rb" "ruby/lib/basecamp/errors.rb"
            "ruby/lib/basecamp/services/**/*.rb" "ruby/lib/basecamp/generated/services/**/*.rb"
            "kotlin/sdk/src/commonMain/kotlin/com/basecamp/sdk/*.kt"
            "kotlin/sdk/src/commonMain/kotlin/com/basecamp/sdk/services/**/*.kt"
            "kotlin/sdk/src/commonMain/kotlin/com/basecamp/sdk/generated/**/*.kt"
            "swift/Sources/Basecamp/*.swift" "swift/Sources/Basecamp/Services/*.swift" "swift/Sources/Basecamp/Generated/**/*.swift"
          )
          gh pr diff "$PR" > /tmp/full.diff

          # Filter diff to only public API files
          python3 -c "
          import sys, re, fnmatch
          diff = open('/tmp/full.diff').read()
          patterns = sys.argv[1:]
          sections = re.split(r'(?=^diff --git)', diff, flags=re.MULTILINE)
          for s in sections:
              m = re.match(r'diff --git a/(\S+)', s)
              if m:
                  path = m.group(1)
                  if any(fnmatch.fnmatch(path, p) for p in patterns):
                      sys.stdout.write(s)
          " "${PATTERNS[@]}" > /tmp/api.diff

          if [ ! -s /tmp/api.diff ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            TITLE=$(gh pr view "$PR" --json title --jq .title)

            # Compose user message
            {
              printf 'PR #%s: %s\n' "$PR" "$TITLE"
              echo ""
              echo "Diff of public API surface files:"
              head -c 100000 /tmp/api.diff
            } > /tmp/user-message.txt

            # Build full prompt YAML: splice user message into the messages array
            # (avoids yaml round-trip which reorders keys and changes scalar styles)
            python3 -c "
with open('.github/prompts/detect-breaking.prompt.yml') as f:
    lines = f.readlines()
with open('/tmp/user-message.txt') as f:
    user_msg = f.read()

# Find where messages array ends: first non-blank top-level key after 'messages:'
insert_at = len(lines)
for i, line in enumerate(lines):
    if i == 0:
        continue
    if line.strip() and not line[0].isspace():
        insert_at = i
        break

entry = ['  - role: user\n', '    content: |\n']
for ln in user_msg.splitlines():
    entry.append('      ' + ln + '\n')

lines[insert_at:insert_at] = entry
with open('/tmp/prompt.yml', 'w') as f:
    f.writelines(lines)

# Validate: last message must be the user message we just added
import yaml
doc = yaml.safe_load(open('/tmp/prompt.yml'))
assert doc['messages'][-1]['role'] == 'user', 'prompt splice failed: last message is not user'
            "
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect breaking changes
        if: steps.api-diff.outputs.skip != 'true'
        id: detect
        uses: actions/ai-inference@v1
        with:
          prompt-file: /tmp/prompt.yml

      - name: Apply breaking label
        if: steps.api-diff.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read response from file to avoid backtick/quote issues in shell
          RESPONSE_FILE="${{ steps.detect.outputs.response-file }}"
          BREAKING=$(jq -r '.breaking' "$RESPONSE_FILE")
          PR=${{ github.event.pull_request.number }}

          if [ "$BREAKING" = "true" ]; then
            ITEMS=$(jq -r '.items[]' "$RESPONSE_FILE" | sed 's/^/- /')
            gh label create breaking --color "B60205" 2>/dev/null || true
            gh pr edit "$PR" --add-label "breaking"

            # Build comment body
            {
              echo "⚠️ **Potential breaking changes detected:**"
              echo ""
              echo "$ITEMS"
              echo ""
              echo "_Review carefully before merging. Consider a major version bump._"
            } > /tmp/breaking-comment.md

            # Find existing bot comment or create new
            EXISTING=$(gh pr view "$PR" --json comments --jq '.comments[] | select(.body | startswith("⚠️ **Potential breaking")) | .id' | head -1)
            if [ -n "$EXISTING" ]; then
              gh api graphql -f query="mutation { updateIssueComment(input: {id: \"$EXISTING\", body: $(jq -Rs . /tmp/breaking-comment.md)}) { issueComment { id } } }"
            else
              gh pr comment "$PR" --body-file /tmp/breaking-comment.md
            fi
          else
            gh pr edit "$PR" --remove-label "breaking" 2>/dev/null || true
          fi

  spec-impact:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build prompt
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR=${{ github.event.pull_request.number }}
          CHANGED=$(gh pr diff "$PR" --name-only | grep -cE '^(spec/|openapi\.json|behavior-model\.json)' || true)
          if [ "$CHANGED" -eq 0 ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            gh pr diff "$PR" -- spec/ openapi.json behavior-model.json > /tmp/spec.diff 2>/dev/null || true
            TITLE=$(gh pr view "$PR" --json title --jq .title)

            # Compose user message
            {
              printf 'PR #%s: %s\n' "$PR" "$TITLE"
              echo ""
              echo "Spec diff:"
              head -c 100000 /tmp/spec.diff
            } > /tmp/user-message.txt

            # Build full prompt YAML: splice user message into the messages array
            # (avoids yaml round-trip which reorders keys and changes scalar styles)
            python3 -c "
with open('.github/prompts/spec-impact.prompt.yml') as f:
    lines = f.readlines()
with open('/tmp/user-message.txt') as f:
    user_msg = f.read()

# Find where messages array ends: first non-blank top-level key after 'messages:'
insert_at = len(lines)
for i, line in enumerate(lines):
    if i == 0:
        continue
    if line.strip() and not line[0].isspace():
        insert_at = i
        break

entry = ['  - role: user\n', '    content: |\n']
for ln in user_msg.splitlines():
    entry.append('      ' + ln + '\n')

lines[insert_at:insert_at] = entry
with open('/tmp/prompt.yml', 'w') as f:
    f.writelines(lines)

# Validate: last message must be the user message we just added
import yaml
doc = yaml.safe_load(open('/tmp/prompt.yml'))
assert doc['messages'][-1]['role'] == 'user', 'prompt splice failed: last message is not user'
            "
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Analyze impact
        if: steps.check.outputs.skip != 'true'
        id: analyze
        uses: actions/ai-inference@v1
        with:
          prompt-file: /tmp/prompt.yml

      - name: Post impact comment
        if: steps.check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMENT_BODY=$(cat "${{ steps.analyze.outputs.response-file }}")
          PR=${{ github.event.pull_request.number }}
          EXISTING=$(gh pr view "$PR" --json comments --jq '.comments[] | select(.body | startswith("## Spec Change Impact")) | .id' | head -1)
          if [ -n "$EXISTING" ]; then
            gh api graphql -f query="mutation { updateIssueComment(input: {id: \"$EXISTING\", body: $(echo "$COMMENT_BODY" | jq -Rs .)}) { issueComment { id } } }"
          else
            gh pr comment "$PR" --body "$COMMENT_BODY"
          fi
